{
  "./sql_files\\example1.sql": {
    "entity_attributes": {
      "Customers": [
        "CustomerID",
        "CustomerName"
      ],
      "Orders": [
        "EmployeeID",
        "OrderDate",
        "OrderID",
        "RegionID",
        "TotalAmount"
      ],
      "OrderDetails": [
        "OrderID",
        "ProductID",
        "Quantity",
        "UnitPrice"
      ],
      "Products": [
        "CategoryID",
        "ProductID",
        "ProductName"
      ],
      "Categories": [
        "CategoryName"
      ],
      "Employees": [
        "EmployeeID",
        "FirstName",
        "LastName"
      ],
      "Regions": [
        "RegionID",
        "RegionName"
      ]
    },
    "queries": [
      {
        "query_id": 1,
        "sql": "SELECT \n    c.CustomerID,\n    c.CustomerName,\n    o.OrderID,\n    o.OrderDate,\n    o.TotalAmount,\n    RANK() OVER(PARTITION BY c.CustomerID ORDER BY o.OrderDate DESC) AS OrderRank,\n    (SELECT SUM(od.Quantity * od.UnitPrice)\n     FROM OrderDetails od\n     WHERE od.OrderID = o.OrderID) AS OrderItemsTotal\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nWHERE o.OrderDate BETWEEN '2024-01-01' AND '2024-12-31'\nORDER BY c.CustomerName, o.OrderDate DESC",
        "entity_attributes": {
          "Customers": [
            "CustomerID",
            "CustomerName"
          ],
          "Orders": [
            "OrderID",
            "OrderDate",
            "TotalAmount"
          ],
          "OrderDetails": [
            "Quantity",
            "UnitPrice"
          ]
        },
        "summary": "This query retrieves customer information along with their associated orders within the year 2024. It selects the CustomerID and CustomerName from the Customers table, and OrderID, OrderDate, and TotalAmount from the Orders table. The query uses a window function RANK() to assign a rank to each order for a customer based on the order date, with the most recent order receiving the highest rank. Additionally, it calculates the total value of items ordered in each order using a subquery that multiplies the quantity and unit price from the OrderDetails table, summing these values for the relevant order. The results are filtered for orders placed between January 1, 2024, and December 31, 2024, and are ordered by customer name and order date in descending order."
      },
      {
        "query_id": 2,
        "sql": "SELECT \n    p.ProductID,\n    p.ProductName,\n    cat.CategoryName,\n    COUNT(*) AS TotalOrders,\n    AVG(od.UnitPrice) AS AverageUnitPrice,\n    SUM(od.Quantity) AS TotalQuantitySold,\n    SUM(od.Quantity * od.UnitPrice) AS TotalSales\nFROM Products p\nJOIN Categories cat ON p.CategoryID = cat.CategoryID\nJOIN OrderDetails od ON p.ProductID = od.ProductID\nJOIN Orders o ON od.OrderID = o.OrderID\nWHERE o.OrderDate >= '2024-06-01'\nGROUP BY p.ProductID, p.ProductName, cat.CategoryName\nHAVING SUM(od.Quantity) > 100\nORDER BY TotalSales DESC",
        "entity_attributes": {
          "Products": [
            "ProductID",
            "ProductName",
            "CategoryID"
          ],
          "Categories": [
            "CategoryName"
          ],
          "OrderDetails": [
            "UnitPrice",
            "Quantity",
            "ProductID",
            "OrderID"
          ],
          "Orders": [
            "OrderDate"
          ]
        },
        "summary": "This query retrieves product sales data including the product ID, product name, category name, total number of orders, average unit price, total quantity sold, and total sales for each product. It joins the Products, Categories, OrderDetails, and Orders tables to aggregate sales data, filtering for orders dated from June 1, 2024, and groups the results by product and category. Additionally, it only includes products with total quantities sold exceeding 100 and sorts the results by total sales in descending order."
      },
      {
        "query_id": 3,
        "sql": "SELECT \n    e.EmployeeID,\n    e.FirstName,\n    e.LastName,\n    r.RegionName,\n    o.OrderID,\n    o.OrderDate,\n    o.TotalAmount,\n    SUM(o.TotalAmount) OVER(PARTITION BY e.EmployeeID, r.RegionName ORDER BY o.OrderDate \n                              ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CumulativeSales,\n    (SELECT AVG(TotalAmount) \n     FROM Orders \n     WHERE EmployeeID = e.EmployeeID) AS AvgEmployeeSales\nFROM Employees e\nJOIN Orders o ON e.EmployeeID = o.EmployeeID\nJOIN Regions r ON o.RegionID = r.RegionID\nWHERE o.OrderDate BETWEEN '2024-03-01' AND '2024-09-30'\nORDER",
        "entity_attributes": {
          "Employees": [
            "EmployeeID",
            "FirstName",
            "LastName"
          ],
          "Orders": [
            "OrderID",
            "OrderDate",
            "TotalAmount",
            "EmployeeID",
            "RegionID"
          ],
          "Regions": [
            "RegionName",
            "RegionID"
          ]
        },
        "summary": "This query retrieves employee details including their sales performance by aggregating order amounts. It selects the EmployeeID, FirstName, LastName from the Employees table, and the RegionName from the Regions table, and the OrderID, OrderDate, and TotalAmount from the Orders table. The query calculates a running total of sales for each employee within each region, partitioned by EmployeeID and RegionName and ordered by OrderDate, called CumulativeSales. Additionally, it computes the average order total for each employee through a subquery that averages the TotalAmount from the Orders table where the EmployeeID matches. The results are filtered to include only orders placed between March 1, 2024, and September 30, 2024."
      }
    ]
  },
  "./sql_files\\example2.sql": {
    "entity_attributes": {
      "users": [
        "*",
        "id",
        "name",
        "signup_date"
      ],
      "orders": [
        "order_date",
        "order_id",
        "product_id",
        "quantity",
        "status",
        "user_id"
      ],
      "products": [
        "product_id",
        "product_name"
      ],
      "recent_orders": [
        "order_id",
        "product_id",
        "user_id"
      ]
    },
    "queries": [
      {
        "query_id": 1,
        "sql": "SELECT u.id, u.name, (\n    SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id AND o.status = 'completed'\n) AS completed_orders\nFROM users u\nWHERE u.signup_date > '2025-01-01'",
        "entity_attributes": {
          "users": [
            "id",
            "name",
            "signup_date"
          ],
          "orders": [
            "user_id",
            "status"
          ]
        },
        "summary": "This query retrieves a list of users from the 'users' table who signed up after January 1, 2025. For each user, it also calculates the number of completed orders from the 'orders' table, where the order's user_id matches the user's id and the order status is 'completed'. The output includes the user's id, name, and the count of their completed orders."
      },
      {
        "query_id": 2,
        "sql": "SELECT user_id, order_id, order_date,\n       SUM(quantity) OVER (PARTITION BY user_id ORDER BY order_date) AS running_total\nFROM orders",
        "entity_attributes": {
          "orders": [
            "user_id",
            "order_id",
            "order_date",
            "quantity"
          ]
        },
        "summary": "This query retrieves the user IDs, order IDs, and order dates from the 'orders' table, and calculates a running total of the quantity of orders for each user, partitioned by the user ID and ordered by the order date. The running total is calculated using the SUM function along with the OVER clause, which allows for cumulative sums based on the specified partitioning and ordering criteria."
      },
      {
        "query_id": 3,
        "sql": "WITH recent_orders AS (\n    SELECT * FROM orders WHERE order_date > '2025-07-01'\n)\nSELECT u.name, ro.order_id, p.product_name\nFROM users u\nJOIN recent_orders ro ON u.id = ro.user_id\nJOIN products p ON ro.product_id = p.product_id",
        "entity_attributes": {
          "users": [
            "name",
            "id"
          ],
          "orders": [
            "order_id",
            "order_date",
            "user_id",
            "product_id"
          ],
          "products": [
            "product_name",
            "product_id"
          ],
          "recent_orders": [
            "order_id",
            "user_id",
            "product_id"
          ]
        },
        "summary": "This query first creates a Common Table Expression (CTE) named 'recent_orders' that selects all columns from the 'orders' table where the 'order_date' is greater than July 1, 2025. The main query then selects the names of users, order IDs from recent orders, and the product names by joining the 'users' table with the 'recent_orders' CTE on the user ID, and then with the 'products' table on the product ID. This effectively retrieves a list of user names along with their recent order IDs and corresponding product names."
      },
      {
        "query_id": 4,
        "sql": "SELECT * FROM users WHERE active = 1",
        "entity_attributes": {
          "users": [
            "*"
          ]
        },
        "summary": "This query selects all columns from the 'users' table where the 'active' status is equal to 1, effectively returning a dataset of users who are currently active."
      },
      {
        "query_id": 5,
        "sql": "SELECT COUNT(*) FROM orders WHERE status = 'pending'",
        "entity_attributes": {
          "orders": [
            "status"
          ]
        },
        "summary": "This query counts the total number of entries in the 'orders' table where the 'status' column has the value 'pending'."
      }
    ]
  }
}